<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Masked Mix — Auto Play</title>
<style>
  html,body {
    margin:0; padding:0; height:100%; background:#000; color:#fff;
    font-family:system-ui, sans-serif;
    display:flex; flex-direction:column; justify-content:center; align-items:center;
  }
  #canvas {
    width:100%; height:100%; display:block; background:#000;
  }
  #startBtn {
    position:absolute; top:50%; left:50%; transform:translate(-50%,50%);
    padding:16px 28px; font-size:18px; border-radius:8px;
    border:none; background:#fff; color:#000;
    z-index:10;
  }
</style>
</head>
<body>
<button id="startBtn">START</button>
<canvas id="canvas"></canvas>

<!-- 隠しvideo要素 -->
<video id="cameraVideo" autoplay muted playsinline style="display:none"></video>
<video id="bgVideo" autoplay loop muted playsinline style="display:none"></video>
<video id="maskVideo" autoplay loop muted playsinline style="display:none"></video>

<script>
(async ()=>{
  const canvas = document.getElementById('canvas');
  const gl = canvas.getContext('webgl');
  const startBtn = document.getElementById('startBtn');

  // === 用意した動画のパス ===
  const bgVideo = document.getElementById('bgVideo');
  bgVideo.src = "background.mp4";   // ←用意した背景動画
  const maskVideo = document.getElementById('maskVideo');
  maskVideo.src = "mask.mp4";       // ←用意したマスク動画

  const cameraVideo = document.getElementById('cameraVideo');

  // --- WebGL 初期化（省略せず簡易化） ---
  function createShader(type,src){
    const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s);
    return s;
  }
  const vs = `
    attribute vec2 a_pos; varying vec2 v_uv;
    void main(){ v_uv=a_pos*0.5+0.5; gl_Position=vec4(a_pos,0,1); }
  `;
  const fs = `
    precision mediump float; varying vec2 v_uv;
    uniform sampler2D u_bg, u_cam, u_mask;
    void main(){
      vec4 bg=texture2D(u_bg,v_uv);
      vec4 cam=texture2D(u_cam,v_uv);
      vec4 mask=texture2D(u_mask,v_uv);
      float lum=(mask.r+mask.g+mask.b)/3.0;
      vec3 outc=mix(bg.rgb,cam.rgb,lum);
      gl_FragColor=vec4(outc,1.0);
    }
  `;
  const prog=gl.createProgram();
  gl.attachShader(prog,createShader(gl.VERTEX_SHADER,vs));
  gl.attachShader(prog,createShader(gl.FRAGMENT_SHADER,fs));
  gl.linkProgram(prog); gl.useProgram(prog);

  const buf=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,buf);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),gl.STATIC_DRAW);
  const loc=gl.getAttribLocation(prog,"a_pos");
  gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

  function makeTex(unit){
    const t=gl.createTexture(); gl.activeTexture(gl.TEXTURE0+unit);
    gl.bindTexture(gl.TEXTURE_2D,t);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
    return t;
  }
  const texBg=makeTex(0), texCam=makeTex(1), texMask=makeTex(2);
  gl.uniform1i(gl.getUniformLocation(prog,"u_bg"),0);
  gl.uniform1i(gl.getUniformLocation(prog,"u_cam"),1);
  gl.uniform1i(gl.getUniformLocation(prog,"u_mask"),2);

  function updateTex(tex,video,unit){
    if(video.readyState>=2){
      gl.activeTexture(gl.TEXTURE0+unit);
      gl.bindTexture(gl.TEXTURE_2D,tex);
      gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,video);
    }
  }

  function resize(){
    const dpr=window.devicePixelRatio||1;
    canvas.width=canvas.clientWidth*dpr;
    canvas.height=canvas.clientHeight*dpr;
    gl.viewport(0,0,canvas.width,canvas.height);
  }
  window.addEventListener('resize',resize); resize();

  function loop(){
    updateTex(texBg,bgVideo,0);
    updateTex(texCam,cameraVideo,1);
    updateTex(texMask,maskVideo,2);
    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(loop);
  }

  startBtn.addEventListener('click', async ()=>{
    startBtn.style.display="none";
    try {
      const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}});
      cameraVideo.srcObject=stream;
      await cameraVideo.play();
      await bgVideo.play();
      await maskVideo.play();
      loop();
    } catch(e){ alert("カメラ起動失敗:"+e); }
  });
})();
</script>
</body>
</html>
